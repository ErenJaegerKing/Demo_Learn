### 知识点巩固

#### 黑盒测试和白盒测试的区别

黑盒测试和白盒测试是软件测试中常用的两种测试方法，它们的主要区别在于测试人员是否了解被测试软件的内部结构和实现细节。 黑盒测试（Black Box Testing）是一种测试方法，它把被测试软件看作一个黑盒子，只关心软件的输入和输出，而忽略软件内部的实现细节。黑盒测试通常通过输入各种不同的数据、使用各种场景和操作组合等方式，来验证软件是否能够正确地响应和输出预期的结果。测试人员通常不需要知道被测试软件的具体实现和内部结构，只需要从用户的角度出发进行测试，以发现软件中的功能性和非功能性问题。 白盒测试（White Box Testing）是一种测试方法，它需要测试人员了解被测试软件的内部结构和实现细节。在白盒测试中，测试人员通常会根据软件的内部结构和实现细节，设计和执行一系列测试用例，以验证软件内部的逻辑是否正确、代码是否符合标准等方面的问题。白盒测试通常需要测试人员具备一定的编程和代码分析能力，以便深入了解软件的内部结构和实现方式，从而更加全面地进行测试。 综上所述，黑盒测试和白盒测试的区别在于测试人员是否了解被测试软件的内部结构和实现细节。在实际测试中，测试人员可以根据测试对象的特点和测试需求，综合使用黑盒测试和白盒测试等多种测试方法，以达到全面、高效、有效地测试目的。

#### 如果出现死锁，怎么排查

1. 查看系统日志和错误信息，了解死锁发生的时间和原因。 
2. 使用命令行工具或者监控工具查看系统资源占用情况，如CPU、内存、磁盘等，以确定是否是资源竞争导致的死锁。 
3. 检查程序代码，查看是否存在多个线程之间相互等待对方释放资源的情况，以及是否存在资源分配不当的情况。
4. 使用工具进行死锁检测，如使用操作系统提供的工具或者第三方工具对程序进行分析，找出可能导致死锁的代码片段。

#### 如何处理击穿呢

我们的业务通常会有几个数据会被频繁地访问，比如秒杀活动，这类被频地访问的数据被称为热点数据。如果缓存中的某个热点数据过期了，此时大量的请求访问了该热点数据，就无法从缓存中读取，直接访问数据库，数据库很容易就被高并发的请求冲垮，这就是缓存击穿的问题。

应对缓存击穿可以采取前面说到两种方案：
·互斥锁方案，保证同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重
新读取缓存，要么就返回空值或者默认值。
·不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程
更新缓存以及重新设置过期时间;

#### 设置缓存永不过期的缺点

缓存永不过期会导致缓存数据可能过时，因为数据在缓存中永不过期，如果数据在源端被更新或删除，缓存中的数据仍然是旧的，可能导致数据不一致的问题。此外，缓存永不过期还会导致占用过多内存，因为缓存中的数据会一直存在，当数据量过大时，会消耗大量内存资源。同时，无法及时更新也是缓存永不过期的缺点，因为数据永不过期，无法及时获取最新数据。

#### 什么是多态

多态是指同一个方法调用可以根据对象的不同类型而具有不同的行为。

多态的实现通常基于继承和接口。在继承中，子类可以重写父类的方法，从而实现多态。而在接口中，不同类实现同一个接口的方法，也可以实现多态。

#### 实际开发中反范式是为什么

反范式设计是指在数据库设计中，为了优化查询性能和降低数据冗余，特意违反范式规则，将数据冗余存储。这样可以减少表的连接操作，提高查询效率。但是反范式设计也会增加数据冗余和更新异常的风险，需要在设计时权衡利弊。

#### 数据库索引一般是用什么数据结构？和其它数据结构有什么区别？

正确答案：数据库索引一般是使用B树或者B+树数据结构。与其它数据结构相比，B树和B+树是一种多路搜索树，能够保持数据有序，并且具有较高的查找效率。 解答思路：数据库索引的目的是为了提高数据的检索效率，常见的数据结构如B树和B+树都可以满足这一要求。B树和B+树相对于其它数据结构的优势在于，它们具有较好的平衡性和稳定性，能够保持树的平衡，减少查询时的IO次数，提高检索效率。 

问题考点的深度知识讲解：B树和B+树是常用的数据库索引数据结构，它们在数据库系统中起着至关重要的作用。B树是一种多路平衡查找树，每个节点可以存储多个关键字，并且具有较好的平衡性。而B+树是在B树的基础上进行了优化，将非叶子节点仅存储指针而不存储数据，使得查询效率更高。在实际应用中，数据库索引的选择取决于具体的场景和需求，需要根据实际情况进行选择。【问题】描述的是数据库索引的数据结构，通过了解B树和B+树的特点和优势，可以更好地理解数据库索引的实现原理和查询效率优化。

#### 双亲委派机制

正确答案：双亲委派机制是Java类加载器的工作原理之一，通过这种机制，类加载器在加载类的时候会先委托给父类加载器去加载，只有在父类加载器无法完成加载的情况下，子类加载器才会尝试加载。 解答思路：双亲委派机制是为了保证Java程序的安全性和稳定性，防止不同类加载器重复加载同一个类，同时也可以防止恶意类的加载。在面试中，可以解释双亲委派机制的原理和作用，以及它对Java类加载器的影响。 问题考点的深度知识讲解：双亲委派机制是Java类加载器的核心原理之一，它遵循了类加载器的双亲委派模型。当一个类加载器收到加载类的请求时，它会先向上委托给父类加载器，直到顶层的启动类加载器。只有在父类加载器无法完成加载时，子类加载器才会尝试加载。这种机制可以保证类的唯一性，避免了类的重复加载，确保了类加载的顺序和一致性。在Java中，Bootstrap ClassLoader、Extension ClassLoader和Application ClassLoader分别代表了三个级别的类加载器，它们之间通过双亲委派机制来协同工作，保证了类的加载过程的有序性和安全性。

#### 说一下Ioc和Aop

正确答案：IOC（Inversion of Control）和AOP（Aspect-Oriented Programming）是面向对象编程中常见的两种编程思想。

解答思路：IOC是一种控制反转的设计模式，它通过将对象的创建、管理及调用控制权交给容器来实现。而AOP是一种面向切面编程的设计模式，它通过在程序运行期间动态地将功能添加到类中，从而实现横切关注点的功能。

问题考点的深度知识讲解：

1. IOC（Inversion of Control）：IOC容器是Spring框架的核心，它通过反转对象的创建和管理流程，实现了对象之间的松耦合，方便了程序的维护和扩展。常见的IOC容器有BeanFactory和ApplicationContext，它们通过读取配置文件或注解来实现对象的管理和依赖注入。
2. AOP（Aspect-Oriented Programming）：AOP是一种编程思想，通过在程序运行期间动态地将功能添加到类中，实现了横切关注点的功能，例如日志记录、事务管理等。AOP的核心概念是切面、连接点、通知、切点和织入，它可以通过代理模式或字节码增强技术来实现

#### 说一下java面向对象的特性

正确答案：Java面向对象的特性包括封装、继承和多态。 

解答思路：首先，封装是指将数据和方法封装在类内部，通过访问权限控制符（public、private、protected）来限制对类的访问，提高安全性和代码复用性。继承是指一个类可以继承另一个类的属性和方法，实现代码的重用和扩展。多态是指同一个方法调用可以根据对象的不同表现出不同的行为，提高代码的灵活性和可扩展性。

 问题考点的深度知识讲解：在Java中，封装通过访问权限控制符和getter/setter方法来实现，可以保护数据不被外部直接访问。继承通过extends关键字实现，子类可以继承父类的属性和方法，同时可以覆盖父类的方法实现多态。多态通过方法的重载和重写来实现，可以提高代码的灵活性和可扩展性。在实际开发中，合理运用这些面向对象的特性可以提高代码的可维护性和可扩展性。

#### 索引选择使用哪些字段

正确答案：在选择索引字段时，需要考虑到查询频率高的字段、数据分布均匀的字段以及经常用于过滤和排序的字段。 

解答思路：首先，我们需要分析业务需求和查询频率，确定哪些字段是经常被查询的，然后选择这些字段作为索引字段。其次，要考虑数据分布的均匀性，选择数据分布均匀的字段可以减少索引的维护成本。最后，如果某些字段经常用于过滤和排序操作，也应该考虑将这些字段加入索引。 

问题考点的深度知识讲解：在数据库中，索引是一种数据结构，用于快速定位和访问数据库表中的数据。选择索引字段需要根据查询需求和数据分布情况来合理设计。常见的索引类型包括单列索引、组合索引、唯一索引等。在创建索引时，需要权衡查询性能和索引维护成本，避免过多或不必要的索引导致性能下降。在实际应用中，可以通过explain命令来分析查询语句的执行计划，帮助优化索引设计。

#### 线程不安全的原因

正确答案：线程不安全的原因可能包括竞态条件、数据竞争、死锁、资源竞争等。 

解答思路：线程不安全的原因主要是因为多个线程同时对共享资源进行读写操作，导致数据不一致或者程序出现异常。竞态条件是指多个线程对同一数据进行读写操作，而最终结果取决于线程执行的顺序。数据竞争是指多个线程同时访问共享数据，导致数据的不一致性。死锁是指多个线程相互等待对方释放资源，导致程序无法继续执行。资源竞争是指多个线程竞争有限的资源，导致某些线程无法获取所需资源而无法继续执行。

 问题考点的深度知识讲解：在多线程编程中，线程不安全是一个常见的问题，需要通过合理的同步机制来解决。常见的同步机制包括互斥锁、信号量、条件变量等。互斥锁可以保证同一时刻只有一个线程访问共享资源，从而避免竞态条件和数据竞争。信号量可以控制多个线程对资源的访问数量，避免资源竞争。条件变量可以实现线程的等待和唤醒操作，避免死锁的发生。在实际编程中，需要了解各种同步机制的原理和适用场景，以确保多线程程序的正确性和性能。

#### 线程池的拒绝策略？

#### 一个类能不能继承多个类，能不能实现多个接口

在Java中，一个类只能继承一个类，但可以实现多个接口。这是因为Java是单继承的，即一个类只能有一个直接父类，但可以实现多个接口。

#### 一个类能不能有多个构造方法

一个类可以有多个构造方法。在Java中，一个类可以有多个构造方法，它们之间通过参数列表的不同来进行区分。这种特性被称为构造方法的重载。当我们实例化一个类的对象时，可以根据需要选择不同的构造方法来初始化对象。

#### 一个烧绳子，一根不均匀的绳子能烧1h，有n根这样的绳子，怎么用这些绳子烧出1h 15min

将第一根绳子的两端同时点燃，同时点燃第二根绳子的一端。当第一根绳子烧完的时候，点燃第二根绳子的另一端。这样可以测量45分钟的时间。接着点燃第三根绳子的一端，当第二根绳子烧完时，点燃第三根绳子的另一端。这样可以测量30分钟的时间。最后，同时点燃第三根绳子的两端，当第三根绳子烧完时，表示15分钟的时间已经过去。

#### 一个是两个数组，要求算中位数，然后给出优化算法

首先，我们可以将两个数组合并成一个有序数组，然后根据数组长度的奇偶性来确定中位数的计算方式。如果数组长度为偶数，中位数是中间两个数的平均值；如果数组长度为奇数，中位数就是中间那个数。

为了优化算法，我们可以使用二分查找的思想来找到中位数。我们可以分别在两个数组中找到一个位置，使得左边部分的元素个数等于右边部分的元素个数，并且左边部分的最大值小于右边部分的最小值。这样就可以确保中位数在这两个位置的元素中产生。

在找到合适的位置后，根据数组长度的奇偶性来计算中位数。如果是偶数，取两个位置的元素的平均值；如果是奇数，取两个位置中较大的那个元素作为中位数。

我们可以在时间复杂度为O(log(min(m,n)))的情况下找到中位数。

#### 一个数组找最长升序子序列，返回最长的值。做出来了然后进阶，当场设计了返回整个子序列

首先，我们可以使用动态规划来解决这个问题。定义一个数组dp，dp[i]表示以nums[i]结尾的最长升序子序列的长度。初始化dp数组为1，然后遍历数组nums，对于每个位置i，我们再次遍历其之前的所有位置j，如果nums[i]大于nums[j]，则更新dp[i]为dp[j]+1，即在原有的最长子序列长度上加1。最终，返回dp数组中的最大值即为最长升序子序列的长度。

#### 在运行时哪些数据是共享的

在运行时，共享的数据包括静态变量、全局变量、常量池中的字符串常量等。

问题考点的深度知识讲解：在Java中，静态变量被存储在方法区中，而实例变量存储在堆中。全局变量和常量池中的字符串常量也是存储在方法区中。在多线程环境下，共享的数据可能会导致线程安全问题，需要使用同步机制来保证数据的一致性。在Java中，可以使用synchronized关键字或Lock接口来实现线程同步。另外，volatile关键字也可以用来保证可见性和有序性。在并发编程中，了解共享数据的特性和线程安全机制是非常重要的。

#### 在java中一个字符串的string是可变的吗

正确答案：在Java中，一个字符串的String是不可变的。

解答思路：在Java中，String类是不可变的，也就是说一旦一个String对象被创建之后，它的值就不能被改变。如果需要更改字符串的内容，实际上是创建了一个新的String对象来存储新的内容，原来的String对象仍然保持不变。这样的设计有利于线程安全和性能优化。

问题考点的深度知识讲解：这个问题考察了Java中字符串的不可变性。Java中的字符串是通过String类来表示的，String类使用final关键字修饰，表示不可被继承，即String类本身是不可变的。字符串的不可变性有助于保证字符串对象的安全性和线程安全性，同时也有利于字符串常量池的优化。如果需要频繁修改字符串内容，推荐使用StringBuilder或StringBuffer类，它们提供了可变的字符串操作方法。

#### 怎么使用 Caffeine 的？结合数据库和 Redis

正确答案：Caffeine 是一个基于 Java 的高性能缓存库，具有自动加载、缓存过期、大小限制等功能。结合数据库和 Redis 可以通过 Caffeine 缓存数据库查询结果或 Redis 数据，提高查询性能和降低数据库或 Redis 的负载压力。

解答思路：首先，我们可以通过 Caffeine 的 LoadingCache 来实现自动加载数据，当缓存中不存在数据时，可以从数据库或 Redis 中加载数据。其次，可以通过 Caffeine 的缓存过期策略和大小限制来管理缓存数据，保证缓存数据的及时更新和合理利用。

问题考点的深度知识讲解：在实际应用中，结合数据库和 Redis 使用 Caffeine 可以有效提升系统性能。通过合理设计缓存数据的加载和更新策略，可以减少不必要的数据库查询或 Redis 访问，减轻系统负载，提高响应速度。同时，需要注意缓存数据的一致性和失效处理，避免数据不一致或过期数据的影响。在使用 Caffeine 缓存时，还需要考虑缓存的大小限制和逐出策略，避免缓存数据过多导致内存溢出或性能下降的问题。综上所述，结合数据库和 Redis 使用 Caffeine 可以充分发挥缓存的作用，提升系统性能和稳定性。

#### 直接排序的时间复杂度

在计算机科学中，直接排序（也称为插入排序）的时间复杂度为O(n^2)。在最坏情况下，需要比较n*(n-1)/2次，而在最佳情况下，需要比较n-1次。解答思路：直接排序是一种简单直观的排序算法，通过将未排序的元素一个个插入到已排序的部分中，来达到排序的目的。其基本思路是从第二个元素开始，逐个将元素插入到已排序序列的合适位置。时间复杂度分析：在最坏情况下，直接排序的时间复杂度为O(n^2)，因为每个元素都要与前面的元素进行比较和移动。在最佳情况下， 如果待排序的数组已经是有序的，直接排序的时间复杂度为O(n)，因为只需要比较n-1次即可完成排序。问题考点的深度知识讲解：直接排序虽然简单，但是在处理大规模数据时效率较低，因为其时间复杂度为O(n^2)，在实际应用中一般不推荐使用。排序算法中常用的高效算法有快速排序、归并排序、堆排序等，它们的时间复杂度通常为O(nlogn)，在处理大规模数据时更加高效。

#### 字典树

正确答案：Trie树（字典树）是一种树形数据结构，用于高效地存储和检索字符串数据集。它的每个节点包含一个指向子节点的指针数组，通常包含26个字母，用于表示26个英文字母。在实际应用中，Trie树常用于实现词典、拼写检查等功能。 

解答思路：Trie树的核心思想是利用字符串的公共前缀来节省存储空间和提高查询效率。通过逐个字符构建树节点，每个节点表示一个字符，根节点为空字符串。在插入和查询过程中，根据字符串中的字符顺序沿着树节点的路径移动，直到找到对应的字符串或无法继续匹配。 

问题考点的深度知识讲解：Trie树的时间复杂度为O(m)，其中m为字符串的平均长度。它可以高效地支持前缀匹配、查找最长公共前缀、按字典序排序等操作。在实际应用中，Trie树常用于实现自动补全、搜索引擎建议功能等。在Trie树的实现过程中，需要考虑节点的数据结构设计、插入和查询算法的优化等问题，以提高效率和减少内存占用。

### 面试题2

#### 项目负责什么，你做的这个模块做了什么

#### ci/cd是什么，你怎么实现的

CI/CD 是持续集成（Continuous Integration）和持续交付/部署（Continuous Delivery/Deployment）的简称，它的主要目的是通过自动化的方式加速软件开发和发布的过程，提高代码质量和交付速度。在我的项目 PmHub 中，就采用了 CI/CD 方法来优化开发流程。

我会使用 Git 进行代码版本控制，仓库托管在 GitHub 上。在确定提交的代码没有问题时，我会将代码提交到 main 分支。

Jenkins 服务器在检测到代码提交后，会自动拉取最新代码，执行构建任务，这包括编译代码和运行各种测试，如单元测试和集成测试。Jenkins 会在每次构建完成后，通过邮件通知我构建状态，无论是成功还是失败，同时提供详细的错误信息，帮助我及时发现和解决问题。

在构建和测试成功后，Jenkins 会自动将新版本的PmHub 部署到生产环境中。

这个自动部署流程确保我能够快速、安全地交付新版本，同时通过环境配置管理保证本地和生产环境的一致性，减少因环境差异导致的问题。

#### 了解过JVM么？讲一下JVM的特性

JVM，也就是 Java 虚拟机，它是 Java 实现跨平台的基石。

Java 程序运行的时候，编译器会将 Java 源代码（.java）编译成平台无关的 Java 字节码文件（.class），接下来对应平台的 JVM 会对字节码文件进行解释，翻译成对应平台的机器指令并运行。

也就实现了 Java 一次编译，处处运行的跨平台性。







